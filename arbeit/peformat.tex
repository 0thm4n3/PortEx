\chapter{Portable Executable Format} \label{chap:peformat}

The library \portex{} extracts information from the \PE{} format to assist in analysing malware. Therefore knowledge about the \PE{} format is neccessary to understand the implementation of \portex{} and why the extracted information is useful for malware analysis. 

Microsoft introduced the \PE{} file format in 1993 with the release of Windows NT 3.1. It is the successor of the \NZ{} file format for 16-bit systems. The \PE{} format has been incrementally changed since then, and supports not only 32-bit, but also 64-bit system architectures today. The \PE{} format is described in the \PECOFF{} \cite{pespec}. 

This chapter defines frequently used terms in \autoref{sec:peconcepts}, gives an overview about the structure of a \PE{} file according to the \PECOFF{} in \autoref{sec:pestructure} and winds up with \PE{} file malformations in \autoref{sec:malformations}.

\section{General Concepts}\label{sec:peconcepts}

This section explains general concepts and frequent terms that are also used by the \PECOFF{} and necessary to understand the descriptions of the \PE{} format.

\subsection*{PE File Types}

The two \PE{} file types are \DLL{} and \EXE{} files. The differentiation between these file types is solely a semantic one. 

\DLL{} files are meant to export functions or data that other programs can use. Therefore they usually only run within the context of other programs. They can have various file extensions, including \emph{.sys}, \emph{.dll}, \emph{ocx}, \emph{.cpl} and \emph{.drv} (\cf{} \cite{micrdll}). 

\EXE{} files run in their own process instead of being loaded into an existing process of another program. They usually have the file extension \emph{.exe} and do not export any symbols. Both file types share the same format and hybrids are possible, \eg{}, an \EXE{} that exports symbols.
%The system recognizes the file type by a certain flag in the \PE{} headers. (see page~\pageref{dllflag}) \todo{other file types? FON?}

\subsection*{Special Terms}

\begin{definition}[linker]
\enquote{\emph{Linking} is the process of collecting and combining various pieces of code and data into a single file that can be loaded (copied) into memory and executed. [...] On modern systems, linking is performed automatically by programs called \emph{linkers}.} \cite[\p{654}]{bryant11}
\end{definition} 

\begin{definition}[loader]
A \emph{loader} is a program that loads a file into main memory.
\end{definition} 

\begin{definition}[image file]
\emph{Image files} have been processed by a linker and are used as input for the loader of the operating system (\cf{} \cite[\p{8}]{pespec}).
\end{definition} 

\EXE{} and \DLL{} files, are considered as \emph{image files} by the \PECOFF{} (\cf{} \cite[\p{8}]{pespec}).

The \PECOFF{} specifies \emph{object files} (Common Object File Format or {COFF}) alongside \emph{image files}. \emph{Object files} are used as input for a linker in contrast to \emph{image files} (see \cite[\p{8}]{pespec}). Although \emph{object files} are described in the \PECOFF{}, they are not part of the present thesis.

\begin{definition}[base address]
The \emph{base address} is the address of the first byte where the image file is loaded in memory (see \enquote{ImageBase} \cite[\p{19}]{pespec}).
\end{definition} 

\begin{definition}[physical address]
A physical address is the offset of a certain byte in a file as it is written on disk. The very first byte of the file has the offset 0.
\end{definition} 

\begin{definition}[RVA]
\emph{\useacronym*[es]{RVA}} are used while an image file is loaded in memory. They are relative to the base address of the image file (see \cite[\p{19}]{pespec}).
\end{definition} 

\begin{definition}[VA]
\useacronym*[es]{VA} are absolute in-memory addresses. A \emph{\VA{}} is the same as a \RVA{} with the base address added (see \cite[\p{19}]{pespec}). 
\end{definition} 

The base address, which is given within the \PE{} file, is only a preferred loading address. If the image file can not be loaded at the preferred address into process space, another base address is applied. Hence, \useacronym[es]{RVA} are a way to specify addresses in-memory independendly from the base address. 

\begin{definition}[entry point]\label{def:entrypoint} 
The \emph{entry point} is a \RVA{} to the starting address for \EXE{} files, or to the initialization function for device drivers (see \cite[\p{18}]{pespec}).
\end{definition}

\begin{definition}[section]
A \enquote{basic unit of code or data within a PE or COFF file} \cite[\p{19}]{pespec} is called a \emph{section}. Sections are defined by their section header in the Section Table (\cf{} \cite[26]{pespec})
\end{definition} 

\section{General Structure} \label{sec:pestructure}

\begin{figure}
\centering
\includegraphics[width=.98\textwidth, height=.60\textheight,keepaspectratio]{graphics/peformat}
\caption{Structure of a PE file}
\label{fig:peformat} 
\end{figure}

\autoref{fig:peformat} illustrates the structure of a \PE{} file. It consists of the PE File Header followed by the Section Table and the sections. The overlay is optional data appended to the file. The different parts of the \PE{} are explained hereafter. 

Different resources use the term \emph{PE File Header} with variable meanings, so the following definition is used in the present thesis. \todo{examples}
\begin{definition}[PE File Header]
The \emph{PE File Header} \enquote{consists of a MS-DOS stub, the PE signature, the COFF file header, and an optional header.} \cite[\p{11}]{pespec}
\end{definition} 

A \PE{} file starts with the MS-DOS Stub. This is an application, which is able to run in MS-DOS. The standard MS-DOS Stub prints the message \enquote{This program cannot be run in DOS mode}. 

The operating system determines the file format by looking for specific signatures. The file format signature is usually at the very beginning of the file. The \PE{} signature (\enquote{PE\textbackslash{}0\textbackslash{}0}) is placed after the MSDOS-Stub, because the MS-DOS Stub has a file format signature (\enquote{MZ}) itself. The offset to the \PE{} signature is defined in the MS-DOS Stub, thus enables Windows to properly execute the \PE{} file.

\renewcommand{\arraystretch}{1.5}
\begin{table}[h]
	\begin{center}
		\begin{tabular}{p{.23\textwidth} p{.48\textwidth} p{.18\textwidth}}
			\toprule
			Header name			& Contents & Size in Bytes PE32/PE32+ \\
			\midrule
			COFF File Header	&  \ia{}, type of target machine, number of sections, time date stamp (when the file was created), size of Optional Header, file characteristics & 20/20\\

		  Optional Header			& Standard Fields, Windows Specific Fields, Data Directory Table & variable\\
      \midrule
      Standard Fields &  \ia{}, magic number, size of code, linker versions, entry point & 28/24\\
			Windows Specific Fields	& \ia{}, operating system the file can run on, file alignment, section alignment, \DLL{} characteristics, number of data directories & 68/88 \\
			Data Directory Table	& each entry consists of address and size for a table or string that the system uses, \eg{}, import table, export table, resource table & variable\\
			\midrule
      Section Table &  each entry is a section header; a section header describes, \ia{}, characteristics, size, name and location of a section & variable\\
			\bottomrule
		\end{tabular}
	\end{center}
	\caption[PE File Header contents]{PE File Header and Section Table contents}
	\label{tbl:peheader}
\end{table}

%The COFF File Header contains information about the type of the target machine, the number of sections, a time date stamp that indicates when the file was created, the size of the Optional Header and flags that indicate file characteristics including a flag that indicates whether the file is a \DLL{}\label{dllflag}.

%The Optional Header follows right after the COFF File Header at a certain offset from the beginning of the PE File Header. Despite its name the Optional Header is mandatory for image files. Only object files do not need it. The Optional Header has three parts: Standard Fields, Windows Specific Fields and a Data Directory Table.

%The Standard Fields of the Optional Header contain information necessary for loading and running the file. They determine for example, whether the image file allows a 64-bit address space (\PEplus{}) or is limited to a 32-bit address space (\PEsmall{}). They also declare \ia{} the size of initialized and uninitialized data, the size of the code, the linker versions and the entry point (see \autoref{def:entrypoint} at page~\pageref{def:entrypoint}) of the image file.

%The Windows Specific fields provide additional information for the Windows loader and linker like the operating systems the image file can run on, alignment values, dll characteristics and the number of data directories in the Data Directory Table.

%A Data Directory Table entry consists of address and size for a table or string that the system uses. Examples are the import table, the export table and the resource table. (see \cite[\pp{24}]{pespec})

%The Section Table is placed right after the Optional Header. It consists of the section headers for the sections that make up the rest of the \PE{} file. A section header describes \ia{} characteristics, size, name and location of a section.

\autoref{tbl:peheader} shows the contents of the PE File Header and the Section Table. The \fieldname{MagicNumber} field of the Optional Header determines  whether the image file allows a 64-bit address space (\PEplus{}) or is limited to a 32-bit address space (\PEsmall{}). Some field sizes vary depending on the \fieldname{MagicNumber} and one field has been removed in \PEplus{} files (\fieldname{BaseOfData}, see \cite[18]{pespec}).

All substructures of the PE File Header are consecutively arranged, thus located at a fixed offset from the beginning of the \PE{} signature. The offset of the Section Table depends on the \fieldname{SizeOfOptionalHeaders} field, which is located in the COFF File Header. The remainder of the \PE{} file contains data at addresses, which are defined in the PE File Header or the Section Table. 

The sections of the \PE{} file may contain any data, only some sections have a special meaning and are explained in \emph{\nameref{sec:specialsections}} below. %An \EXE{} file has at least one section containing executable code.

Data that was appended to the file, but is not part of the \PE{} format is called \emph{overlay}. Overlay is not mapped into memory. The overlay is used by some applications as a way to store data without having to deal with the \PE{} format or to prevent the operating system from loading the data to memory. 

\section{Special Sections} \label{sec:specialsections}

Sections may contain data that is only relevant for certain applications or not relevant at all; but some sections have a special meaning. Their format is described in the \PECOFF{} \cite[\p{74-103}]{pespec}. 

\PE{} parsers and the Windows loader determine special sections by entries in the Data Directory Table of the Optional Header or certain flags in the Section Table. Special sections have typical section names which are also used in the \PECOFF{} to refer to the sections. These names are not mandatory, but a convention. That is why they are not reliable for finding certain sections in a \PE{}. Not only malware writers misuse the section names to obscure their purpose, but also legitimate compilers and packers violate the convention (\eg{} the packer UPX \footnote{\url{http://upx.sourceforge.net/}}). A subset of these special sections is described in the following.\todo{sections that are recognized by portex}

\subsection*{Export Section} \label{subsec:idata}

The \emph{.edata Section} or \emph{Export Section} is generally found in \useacronym[s]{DLL}. The section begins with the Export Directory Table, which contains general information and addresses to resolve imports from this section. The Export Directory Table points to an array of addresses called Export Address Table. Each address either points to code or data within the current image file, or is a forwarder address which points to a symbol in another \DLL{}. 

Other image files have two ways to import symbols from the current image file: They either use an index into the Export Address Table (the index is also called \emph{ordinal}) or they use a public name of the symbol. Ordinals are defined in the Ordinal Table; public names are defined in the Export Name Table.

Entries of the Ordinal Table correspond to the Export Name Pointer Table entries by their position. Every entry is an ordinal that represents an index in the Export Address Table.

The Export Name Pointer Table is an array of addresses which point to names of the Export Name Table. These names are null-terminated ASCII strings. They are the public names that other image files can use to import the symbols.

\autoref{lst:exportsample} shows example contents for a \DLL{} with two exported symbols: \texttt{DLL2Print} and \texttt{DLL2ReturnJ}. It also illustrates in lines 34-40 how the information from the different tables is combined.

\lstinputlisting[caption={Example for Export Section contents, output by \portex{}},captionpos=t,label=lst:exportsample]{listings/edata_sample}

\subsection*{Import Section}

\begin{figure}
\centering
\includegraphics[width=.98\textwidth, height=.60\textheight,keepaspectratio]{graphics/importsection}
\caption{Typical Import Section Layout by \protect{\cite[\p{61}]{pespec}}}
\label{fig:import} 
\end{figure}

Every image file that imports symbols has an \emph{Import Section}, also called \emph{.idata Section}.
The Import Section contains the Import Directory Table, several Import Lookup Tables, the Hint-Name Table and the \IAT{}. A typical layout of the Import Section is in \autoref{fig:import}

Every Import Directory Table entry points to an Import Lookup Table. Each Import Lookup Table describes the imported symbols of a single \DLL{}.

The Hint-Name table entries have a hint and an ASCII name of the import. Each hint is an index to the Export Name Pointer Table (see \autoref{subsec:idata}) of the \DLL{} the current file is importing from. Hints speed up the lookup of imports.

Null entries mark the end of the Import Directory Table and the Import Lookup Table.

The \IAT{} is identical to the Import Directory Table except while the image is bound. In the latter case the \IAT{} entries are overwritten with memory addresses of the imported symbols.

\subsection*{Resource Section}

Resources of a \PE{} can be \ia{} icons, text, windows, copyright information. They are saved as an entry in the \emph{Resource Section}, which also has the name \emph{.rsrc Section}. The Resource Section is build up as a tree with the actual resource addresses as leaves. While \(2^{31}\) tree levels can be used according to the \PECOFF{} \cite[\p{100}]{pespec}, Windows only uses three levels with the first level node being the type, the second being the name and the third being the language information. \autoref{fig:resourcetree} illustrates the structure of a resource tree.

\begin{figure}
\includegraphics[width=.98\textwidth, height=\textheight,keepaspectratio]{graphics/resourcetree}
\caption{ Resource tree structure by \protect{\cite{kath13}}}
\label{fig:resourcetree} 
\end{figure}

\subsection*{Debug Section and Debug Directory}

Whereas most sections can be at an arbitrary location in the file, the \emph{Debug Section} (aka \emph{.debug Section})--if it exists--must be placed at the very end of the image file. The reason is that the loader does not map this section into memory. Image files contain per default of the linker only a Debug Directory (as pointed to by the Data Directory Table), but not a Debug Section (see \cite[\p{78}]{pespec}). Thus the Debug Directory is either located in the Debug Section if it exists, in any other section of the \PE{} or not in any section at all.

Every Debug Directory entry defines \ia{} size, location and the type (format) of a debug information block. An example is in \autoref{lst:debugsample}

\lstinputlisting[caption={Example for a Debug Section entry, output by \portex{}},captionpos=t,label=lst:debugsample]{listings/debug_sample}

%\begin{sidewaysfigure}
%\includegraphics[height=.39\textheight,keepaspectratio]{graphics/pe101}
%\caption{ Loading Process of a PE by \protect{\cite{peloading}}. Note that the term PE File Header is used synonymously to COFF File Header in this graphic}
%\label{fig:loading} 
%\end{sidewaysfigure}

\section{PE Malformations} \label{sec:malformations}

\begin{definition}[Malformation]
A \emph{malformation} is data or layout of a \PE{} file that violates the \PECOFF{}.
\end{definition} 

Malformations are either accidental results of \PE{} modifications or done on purpose.
A malformation does not necessarily prevent the Windows loader from running the file. The Windows loader does not work in full compliance with the \PECOFF{} to maintain backward compatibility with obsolete compilers and files. Malware writers utilize the loader's behaviour to create normally working \PE{} files that can not be parsed by most tools used for malware analysis. Some malformations, like setting reserved fields, are also done to hide information in a \PE{}; for example marking a host file as infected to prevent a virus from infecting it twice.

Accidental malformations occur if the malware writer does not know the \PECOFF{} enough to perform modifications in compliance with it. An example is a virus that spreads by adding a new section to the host file, copying the own code into it and changing the entry point to the beginning of the new section. The changes done to the host file can lead to subsequent malformations without impairing the Windows loader while running the file.

Sheehan et\thinspace{}al states that 68~\% of all image files have malformations. \cite[slide 7]{sheehan07}
Because \portex{} specializes in \PE{} malware, one goal of \portex{} is to parse malformated \useacronym[s]{PE} correctly and to recognize malformations.

%While other sources only use the term malformation for a file that still runs normally, this is not a premise for the present thesis. If modifications to a \PE{} done by malware lead to a non-working host file, the file might still be of interest for malware analysis. \portex{} shall still be able to get as much information of the file as possible despite the damage done to the file. \todo{ausdruck? remove paragraph?}

The following malformation examples are modifications done on purpose to deceive malware analysis tools.

\subsection{Simple Malformations}

A malformation is \emph{simple} if it concerns a single field or data table in the \PE{} (\cf{} \cite[slide 7]{vuksan11}).
The malformation examples described hereafter are in ascending order of their complexity. \todo{remove?}

\subsubsection*{Too Many Sections}

According to the \PECOFF{} the number of sections is limited to 96 \cite[\p{12}]{pespec}. While Windows XP refuses to execute a \PE{} with more sections, Windows Vista, 7 and 8 run it nevertheless. The number of sections is defined in the COFF File Header in a 16-bit value. If the maximum number of 0xffff (65535) sections is set, tools might fail to allocate enough memory to load the file and crash subsequently. An example is IDA v5.3.

\subsubsection*{PE File Header in Overlay}

The PE File Header usually follows after the MS-DOS Stub \todo{pespecreferences, usual vs change}

As explained in \autoref{sec:pestructure} the address to the beginning of the PE signature and the following PE File Header is located in file offset 0x3c within the MS-DOS Stub. This address is a 32-bit value and can be changed to point to the overlay of the file as illustrated in \autoref{fig:overlayheader}. (\cf{} \cite[slide 13]{vuksan11})

\begin{figure}
\includegraphics[width=.98\textwidth, height=.60\textheight,keepaspectratio]{graphics/overlayheader}
\caption{PE File Header in Overlay \protect{(\cf{} \cite[slide 13]{vuksan11})}}
\label{fig:overlayheader} 
\end{figure}

The overlay is never mapped into memory, so the PE File Header will not be present in memory as well. The Windows loader reads it from disk and the file will be executed nevertheless. Tools that read the PE File Header from memory can break because of that malformation.

\subsubsection*{Section Table in Overlay}

The idea from the previous malformation is extended by moving only the Section Table to the overlay. The Optional Header has a variable size. The offset from the beginning of the Optional Header and its size determine the beginning of the Section Table. The size is defined in the field \fieldname{SizeOfOptionalHeaders} the COFF File Header. It is a 16-bit value, so the maximum value for the size is 65535. If the end of the file is smaller than the offset of the Optional Header plus its size, the Section Table can be moved to the very end of the file. \autoref{fig:overlaysectable} illustrates the malformation.

As a result of this modification the Section Table will not be mapped to memory. A tool that parses the memory content will not be able to find the Section Table. Pericin demonstrates this in his talk at the BlackHat Conference with the debugger OllyDbg. \cite[min.\thinspace{}14:45]{vuksan11} 

\begin{figure}
\includegraphics[width=.98\textwidth, height=.60\textheight,keepaspectratio]{graphics/overlaysectable}
\caption{Section Table in Overlay \protect{(\cf{} \cite[slide 14]{vuksan11})}}
\label{fig:overlaysectable} 
\end{figure}

\subsubsection*{Dual PE File Header} \label{subsubsec:dualheader}

The \fieldname{SizeOfHeaders} field in the Optional Header defines the \enquote{combined size of an MS-DOS Stub, PE File Header, and section headers} \cite[\p{20}]{pespec}. But it also determines the \VA{} of the first section implicitly. \cite[slide 15]{vuksan11} 

If the \fieldname{SizeOfHeaders} field is modified to a smaller value, the modification will result in loading only part of the PE File Header to memory. The Windows loader still processes most of the PE File Header on disk regardless of the \fieldname{SizeOfHeaders} field. So setting the \VA{} of the first section in the Section Table to the same value of the \fieldname{SizeOfHeaders} field will make the section part of the PE File Header in memory whereas the PE File Header read on disk is another one. \autoref{fig:dualpeheader} illustrates the malformation.

The Data Directory Table is parsed from memory by the operating system. That means writing a different continuation of the PE File Header to the first section will result into \eg{} different imports or exports used by the operating system than the ones parsed on disk by reverse engineering tools.

\begin{figure}
\includegraphics[width=.98\textwidth, height=.60\textheight,keepaspectratio]{graphics/dualpeheader}
\caption{Dual PE File Header}
\label{fig:dualpeheader} 
\end{figure}

\subsubsection*{Writeable PE File Header} \label{subsubsec:writeableheader}

The PE File Header usually has only \texttt{execute} and \texttt{read} attributes enabled. There are two possibilities to make it writeable. 

The first possibilitiy is setting the \fieldname{FileAlignment} and the \fieldname{SectionAlignment} to 0x200 (512) or smaller. Both values are part of the Optional Header. 0x200 is the minimum value according to the \PECOFF{} \cite[\p{19}]{pespec}. If the value in the PE File Header is smaller, the Windows loader rounds it up to 0x200.
These changes force the Windows loader to provide full access to the PE File Header. (\cf{} \cite[\p{6}]{revlabs11})

The second possibility is placing the PE File Header in a section as explained in \emph{\nameref{subsubsec:dualheader}} and enabling the \texttt{write} attribute in the section header.

This malformation is necessary for some of the complex malformations following after.

\subsection{Complex Malformations}

A malformation is complex if it concerns multiple fields or data tables in the \PE{} (\cf{} \cite[slide 7]{vuksan11}).

\subsubsection*{No Sections}

Despite having no sections a \PE{} is able to execute code by placing instructions within the PE File Header. This is demonstrated by Sotirov in his \emph{Tiny PE} project. \cite{tinype}

To make this work, the file has to be modified so that the physical offsets are the same as their virtual counterparts. The PE File Header is made writable as explained in \emph{\nameref{subsubsec:writeableheader}} and the number of sections is set to 0. The \fieldname{SizeOfHeaders} field in the Optional Header needs to be large to enough to make Windows load the whole file into memory. That way the \PE{} can execute code inside its PE File Header.

A \PE{} without sections may be partly unreadable by reverse engineering tools as a result of incorrect address conversions; or might be able to break tools that expect the file to have at least one section. An example is Hiew v8.03 which does not recognize a sectionless \PE{} as \PE{} file.
